package away3dlite.loaders{	import away3dlite.arcane;	import away3dlite.core.utils.Cast;	import away3dlite.containers.*;	import away3dlite.core.base.*;	import away3dlite.materials.*;	import flash.geom.*;	use namespace arcane;	/**	 * File loader/parser for the native .awd data file format.<br/>	 */	public class AWData extends AbstractParser	{		private var objs:Array = [];		private var geos:Array = [];		private var oList:Array = [];		private var aC:Array = [];		private var resolvedP:String = "";		private var url:String = "";		private var customPath:String = "";		/** @private */		arcane override function prepareData( data:* ):void {			var awdData:String = Cast.string( data );			var lines:Array = awdData.split( '\n' );			if( lines.length == 1 ) lines = awdData.split( String.fromCharCode( 13 ) );			//var trunk:Array;			var state:String = "";			var isMesh:Boolean;			var isMaterial:Boolean;			var id:int = 0;			var buffer:int = 0;			var oData:Object;			var dline:Array;			var m:Matrix3D;			var cont:ObjectContainer3D;			var i:uint;			var version:String = "";			for each ( var line:String in lines ) {				if( line.substring( 0, 1 ) == "#" && state != line.substring( 0, 2 ) ) {					state = line.substring( 0, 2 );					id = 0;					buffer = 0;					if( state == "#v" )						version = line.substring( 3, line.length - 1 );					if( state == "#f" ) {						isMaterial = (parseInt( line.substring( 3, 4 ) ) == 2) as Boolean;						resolvedP = "";						if( isMaterial ) {							if( customPath != "" ) {								resolvedP = customPath;							} else if( url != "" ) {								var pathArray:Array = url.split( "/" );								pathArray.pop();								resolvedP = (pathArray.length > 0) ? pathArray.join( "/" ) + "/" : pathArray.join( "/" );							}						}					}					if( state == "#t" )						isMesh = (line.substring( 3, 7 ) == "mesh") as Boolean;					continue;				}				dline = line.split( "," );				if( dline.length <= 1 )					continue;				if( state == "#o" ) {					if( buffer == 0 ) {						id = dline[0];						m = new Matrix3D( new Vector.<Number>( [parseFloat( dline[1] ),parseFloat( dline[5] ),parseFloat( dline[9] ),parseFloat( dline[2] ),parseFloat( dline[6] ),parseFloat( dline[10] ),parseFloat( dline[3] ),parseFloat( dline[7] ),parseFloat( dline[11] ),parseFloat( dline[4] ),parseFloat( dline[8] ),parseFloat( dline[12] ),0,0,0,1] ) );						++buffer;					} else {						if( customPath != "" )							var standardURL:Array = dline[12].split( "/" );						m.position = new Vector3D( parseFloat( dline[9] ), -parseFloat( dline[10] ), parseFloat( dline[11] ) );						oData = {name:(dline[0] == "") ? "m_" + id : dline[0] ,							transform:m,							container:parseInt( dline[4] ),							bothsides:(dline[5] == "true") ? true : false,							sortType: (dline[7] == "false" && dline[8] == "false") ? SortType.CENTER : ((dline[7] == "true") ? SortType.FRONT : SortType.BACK),							material:(isMaterial && dline[12] != null && dline[12] != "") ? resolvedP + ((customPath != "") ? standardURL[standardURL.length - 1] : dline[12]) : null};						objs.push( oData );						buffer = 0;					}				}				if( state == "#d" ) {					switch(buffer) {						case 0:							id = geos.length;							geos.push( {} );							++buffer;							geos[id].aVstr = line.substring( 2, line.length );							break;						case 1:							geos[id].aUstr = line.substring( 2, line.length );							geos[id].aV = read( geos[id].aVstr ).split( "," );							geos[id].aU = read( geos[id].aUstr ).split( "," );							++buffer;							break;						case 2:							geos[id].f = line.substring( 2, line.length );							buffer = 0;							objs[id].geo = geos[id];					}				}				if( state == "#c" && !isMesh ) {					id = parseInt( dline[0] );					cont = new ObjectContainer3D();					m = new Matrix3D( new Vector.<Number>( [parseFloat( dline[1] ),parseFloat( dline[5] ),parseFloat( dline[9] ),parseFloat( dline[2] ),parseFloat( dline[6] ),parseFloat( dline[10] ),parseFloat( dline[3] ),parseFloat( dline[7] ),parseFloat( dline[11] ),parseFloat( dline[4] ),parseFloat( dline[8] ),parseFloat( dline[12] ),0,0,0,1] ) );					cont.transform.matrix3D = m;					cont.name = (dline[13] == "null" || dline[13] == undefined) ? "cont_" + id : dline[13];					aC.push( cont );					if( aC.length > 1 )						aC[0].addChild( cont );				}			}			var ref:Object;			var mesh:Mesh;			var j:int;			var av:Array;			var au:Array;			var aRef:Array;			var index:int;			for( i = 0; i < objs.length; ++i ) {				ref = objs[i];				index = 0;				if( ref != null ) {					mesh = new Mesh();					mesh.type = "awd";					mesh.bothsides = ref.bothsides;					mesh.name = ref.name;					mesh.transform.matrix3D = ref.transform;					mesh.sortType = ref.sortType;					mesh.material = (ref.material == null) ? ref.material : new BitmapFileMaterial( unescape( ref.material ) );					if( ref.container != -1 && !isMesh )						aC[ref.container].addChild( mesh );					aRef = ref.geo.f.split( "," );					for( j = 0; j < aRef.length; j += 6 ) {						av = ref.geo.aV[parseInt( aRef[j], 16 )].split( "/" );						mesh._vertices.push( parseFloat( av[0] ), -(parseFloat( av[1] )), parseFloat( av[2] ) );						av = ref.geo.aV[parseInt( aRef[j + 1], 16 )].split( "/" );						mesh._vertices.push( parseFloat( av[0] ), -(parseFloat( av[1] )), parseFloat( av[2] ) );						av = ref.geo.aV[parseInt( aRef[j + 2], 16 )].split( "/" );						mesh._vertices.push( parseFloat( av[0] ), -(parseFloat( av[1] )), parseFloat( av[2] ) );						mesh._indices.push( index, index + 1, index + 2 );						mesh._faceLengths.push( 3 );						index += 3;						au = ref.geo.aU[parseInt( aRef[j + 3], 16 )].split( "/" );						mesh._uvtData.push( parseFloat( au[0] ), 1 - parseFloat( au[1] ), 0 );						au = ref.geo.aU[parseInt( aRef[j + 4], 16 )].split( "/" );						mesh._uvtData.push( parseFloat( au[0] ), 1 - parseFloat( au[1] ), 0 );						au = ref.geo.aU[parseInt( aRef[j + 5], 16 )].split( "/" );						mesh._uvtData.push( parseFloat( au[0] ), 1 - parseFloat( au[1] ), 0 );					}					mesh.buildFaces();				}			}			_container = isMesh ? mesh : aC[0];			cleanUp();		}		private function cleanUp():void {			for( var i:int = 0; i < objs.length; ++i ) {				objs[i] == null;			}			objs = geos = oList = aC = null;		}		private function read( str:String ):String {			var start:int = 0;			var chunk:String;			//var end:int= 0;			var dec:String = "";			var charcount:int = str.length;			for( var i:int = 0; i < charcount; ++i ) {				if( str.charCodeAt( i ) >= 44 && str.charCodeAt( i ) <= 48 ) {					dec += str.substring( i, i + 1 );				} else {					start = i;					chunk = "";					while(str.charCodeAt( i ) != 44 && str.charCodeAt( i ) != 45 && str.charCodeAt( i ) != 46 && str.charCodeAt( i ) != 47 && i <= charcount) {						i++;					}					chunk = "" + parseInt( "0x" + str.substring( start, i ), 16 );					dec += chunk;					i--;				}			}			return dec;		}		/**		 * Creates a new <code>AWData</code> object, a parser for .awd files.		 * @see away3dlite.loaders.AWData#load()		 * @see away3dlite.loaders.AWData#parse()		 */		public function AWData() {		}		/**		 * Parses and creates an Object3D from the raw ascii data of an .awd file. The Away3D native.awd data files.		 * Exporters to awd format are available in Away3d exporters package and in PreFab3D export options		 *		 * @param	data				The ascii data of a .awd file.		 * @param	data				[optional] If the url for the source materials muts be changed.		 * Standard urls set for image sources from Prefab3D awd exports is "images/filename.jpg"		 * Example:		 * [Embed(source="aircraft/Aircraft.awd", mimeType="application/octet-stream")]		 * private var Aircraft:Class;		 * [...] awaylite code		 * var myoutput:Object3D = AWData.parse(new Aircraft(), "mydisc/myfiles/");//path becomes then "mydisc/myfiles/filename.jpg"		 * scene.addChild(myoutput);		 *		 * @return						An Object3D representation of the .awd file.		 */		public static function parse( data:*, sourcesUrl:String = "" ):Object3D {			data = Cast.string( data );			var parser:AWData = new AWData();			if( sourcesUrl != "" )				parser.pathToSources = sourcesUrl;			parser.prepareData( data );			return parser._container;		}		/**		 * Allows to set custom path to source(s) map(s) other than set in file		 * Standard output url from Prefab awd files is "images/filename.jpg"		 * when set pathToSources, url becomes  [newurl]filename.jpg.		 * Example: AWData.pathToSources = "mydisc/myfiles/";		 * Only required for load method using Loader3D		 * var awd:AWData = new AWData();		 * awd.pathToSources = "mydisc/myfiles/";		 * loader = new Loader3D();		 * loader.addEventListener(Loader3DEvent.LOAD_SUCCESS, onSuccess);		 * loader.loadGeometry("mymodels/car.awd", awd);		 *		 */		public function set pathToSources( url:String ):void {			customPath = url;		}	}}